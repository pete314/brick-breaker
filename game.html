<!DOCTYPE html>
<html>
    <head>
        <title>TODO supply a title</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" type="text/css" href="./style/main.css" />
    </head>
    <body class="bodygame">
        <canvas id="gamecanvas"></canvas>
        
        <script src="./js/objects/brick.js"></script>
        <script src="./js/objects/ball.js"></script>
        <script type="text/javascript">
            //Init cavas
            var canvas = document.getElementById('gamecanvas');
            var ctx = canvas.getContext('2d');
            
            ctx.canvas.width  = 550;//window.innerWidth;
            ctx.canvas.height = 768;//window.innerHeight;
            
            var brickArray = [];
            var ball = new Ball(ctx, 250, 450, 10, 10, "red", 10);
            ball.drawBall();

            function initBricks(){
                var brick_id_cnt = 0;
                var brick_skip_cnt = 0;
                //constants
                var BRICK_CONSTANTS = {width: 65, height: 65, gap: 10, min_skip: 1, max_skip: 8};

                //calculate bricks per row based on dinamic width (remove 10pc margin both sides)
                var column_cnt =  Math.floor((this.ctx.canvas.width - 20) / (BRICK_CONSTANTS.width + (BRICK_CONSTANTS.gap / 2)));

                var bricksToSkip = getRandomNumToSkip(BRICK_CONSTANTS.min_skip, BRICK_CONSTANTS.max_skip);
                //var bricks = Array();
                for(var y = 0; y < 5; y++){
                    for(var i = 0; i < column_cnt; i++){
                        if(bricksToSkip === brick_skip_cnt){
                            var brick = new Brick(
                                ctx, 
                                BRICK_CONSTANTS.height,
                                BRICK_CONSTANTS.width,
                                y === 0 ? 0 : y * (BRICK_CONSTANTS.height + (BRICK_CONSTANTS.gap /2)),
                                i === 0 ? 0 : i * (BRICK_CONSTANTS.width + (BRICK_CONSTANTS.gap /2)),
                                "yellow",
                                brick_id_cnt
                            );
                            brick.drawBrick();
                            brickArray[brick_id_cnt] = brick;
                            brick_id_cnt += 1;
                            brick_skip_cnt = 0;
                            bricksToSkip = getRandomNumToSkip(BRICK_CONSTANTS.min_skip, BRICK_CONSTANTS.max_skip);
                        }else{
                            brick_skip_cnt +=1;
                        }
                    }
                }
                console.log("number of bricks " + brick_id_cnt);
            }

            function getRandomNumToSkip(min, max){
                return Math.floor(Math.random() * (max - min +1 )) + min;
            };
            
            function animateBall()
            {
                ctx.fillStyle = "black";  
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                for(var i = 0; i < brickArray.length; i++){
                    var doesCollide = brickArray[i].checkColliding(ball, brickArray[i]);
                    
                    if(!doesCollide){
                        brickArray[i].drawBrick();
                    }else{
                        break;
                    }
                }
                ball = ball.updateBall();
                ball.drawBall();
                ctx = ball.getCtx();
                //requestAnimationFrame(animateBall);
            }
            
            initBricks();
            setInterval(animateBall, 10);
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            //resize to fit window
//            ctx.canvas.width  = 550;//window.innerWidth;
//            ctx.canvas.height = 768;//window.innerHeight;
//            
//            var bricks = new Bricks(ctx);
//            var brickArray = [];
//            brickArray = bricks.initBricks();
//            var ball = new Ball(ctx, 250, 450, 10, 10, "red", 10);
//            ball.draw();
//            
//            
//            
//            var checkAllColliding = function(ball){
//                //check all bricks
//                for(i = 0; i < brickArray.length; i++){
//                    var doesCollide = this.checkColliding(ball, brickArray[i]);
//                    if(doesCollide === true){
//                        console.log(ball, brickArray[i]);
//                        ball.changeVx();
//                        brickArray[i].setColor("red");
//                        break;
//                    }
//                }
//            };
//
//            // return false if not colliding
//            var checkColliding = function(ball, currentBrick){
//                   if(ball.getXpos() - currentBrick.getBrickXpos() < ball.Ballradius + currentBrick.width){
//                       return true;
//                   }
//                   if(ball.getYpos() - currentBrick.getBrickYpos() < ball.Ballradius + currentBrick.width){
//                       return true;
//                   }
//                   
//                   return false;
////                   dx = ball.getXpos() - currentBrick.getBrickXpos();
////                   dy = ball.getYpos() - currentBrick.getBrickYpos();
////
////                   /* Determine the straight-line distance between the centers. */
////                   d = Math.sqrt((dy*dy) + (dx*dx));
////
////                   /* Check for solvability. */
////                   if (d > (ball.Ballradius + currentBrick.width)) {
////                       /* no solution. circles do not intersect. */
////                       return false;
////                   }
////                   if (d < Math.abs(ball.Ballradius - currentBrick.height)) {
////                       /* no solution. one circle is contained in the other */
////                       return false;
////                   }
////                   return true;
//                
//                   
//            };
//
//            var redrawBricks = function(){
//                for(i = 0; i < brickArray.length; i++){
//                    brickArray[i].draw();
//                }
//            };
//            step();
//            function step(){
//              ctx.clearRect(0, 0, canvas.width, canvas.height);
//              checkAllColliding(ball);
//              redrawBricks();
//              ball = ball.update();
//              requestAnimationFrame(step);
//            }
            
        </script>
    </body>
</html>
